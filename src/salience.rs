use crate::faction::{Faction, FactionID};
use crate::node::Node;
use crate::resource::{Resource, ResourceProcess};
use crate::root::Root;
use crate::unit::{Mobility, UnitClass};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use std::sync::RwLock;

//this takes an unbounded threat value and converts it to a multiplier between zero and one by which to scale saliences as they pass through the node
pub fn scale_from_threat(threat: f32, scaling_factor: f32) -> f32 {
    if scaling_factor <= 0. {
        panic!(
            "Attempted to scale by nonpositive factor {}",
            scaling_factor
        );
    }

    let base = 0.95;
    let minimum_valid_threat_value = threat.abs() + scaling_factor;
    let downscaled_threat = minimum_valid_threat_value / scaling_factor;

    let delta_base = 1. - (1. / downscaled_threat);
    let maximum_delta = if threat >= 0. { 0.05 } else { -0.95 };
    let delta = maximum_delta * delta_base;

    base + delta
}

//polarity denotes whether a salience value represents supply or demand
//threat doesn't have demand
//at least not yet
//we might want to change that eventually
pub trait Polarity {}

//we put polarities in a dummy module for syntactic prettiness reasons
pub mod polarity {

    use super::Polarity;

    #[derive(Copy, Clone)]
    pub struct Supply {}

    impl Polarity for Supply {}

    #[derive(Copy, Clone)]
    pub struct Demand {}

    impl Polarity for Demand {}
}

pub trait Salience<P: Polarity> {
    //this retrieves the value of a specific salience in a specific node
    fn calculate_node_salience(
        self,
        root: &Root,
        node: Arc<Node>,
        faction: Arc<Faction>,
        battle_duration: u64,
    ) -> Option<f32>;
}

//this method retrieves threat value generated by a given faction
impl Salience<polarity::Supply> for Arc<Faction> {
    fn calculate_node_salience(
        self,
        _root: &Root,
        node: Arc<Node>,
        faction: Arc<Faction>,
        battle_duration: u64,
    ) -> Option<f32> {
        let node_strength: u64 = node.get_strength(self.clone(), battle_duration);
        //here we get the relations value -- the subject faction's opinion of the object faction, which will influence the threat value
        let relation = faction
            .relations
            .get(&FactionID::new_from_index(self.id))
            .unwrap();
        Some(node_strength)
            .filter(|&strength| strength != 0)
            .map(|strength| strength as f32 * relation * self.value_mult)
    }
}

impl Salience<polarity::Demand> for Arc<Faction> {
    fn calculate_node_salience(
        self,
        root: &Root,
        node: Arc<Node>,
        faction: Arc<Faction>,
        _battle_duration: u64,
    ) -> Option<f32> {
        //Here, we don't take the object faction's relations with the subject faction into account at all,
        //because subjectivity isn't really relevant for threat demand.
        //NOTE: Doing this by retrieving the data from salience state (rather than by looking at assets in the node directly) means that a node will want friendly forces corresponding to assets in other nodes
        //which are propagating salience into it. Not sure if this is desirable behavior.
        if faction == self {
            let resource_salience_by_node: Vec<Vec<[f32; 2]>> =
                transpose(&root.global_salience.resource_salience.read().unwrap()[self.id]);
            let resource_supply: f32 = resource_salience_by_node[node.id]
                .iter()
                .map(|array| array[0])
                .sum();
            let unitclass_salience_by_node: Vec<Vec<[f32; 2]>> =
                transpose(&root.global_salience.unitclass_salience.read().unwrap()[self.id]);
            let unitclass_supply: f32 = unitclass_salience_by_node[node.id]
                .iter()
                .map(|array| array[0])
                .sum();
            let node_value = resource_supply + unitclass_supply;
            let node_object_faction_supply =
                root.global_salience.faction_salience.read().unwrap()[self.id][self.id][node.id][0];
            Some(
                ((node_value
                    * self.volume_strength_ratio
                    * root.config.salience_scalars.volume_strength_ratio)
                    - node_object_faction_supply.clamp(0.0, f32::MAX))
                    * self.value_mult,
            )
        } else {
            None
        }
    }
}

//this method tells us how much supply there is of a given resource in a given node
impl Salience<polarity::Supply> for Arc<Resource> {
    fn calculate_node_salience(
        self,
        _root: &Root,
        node: Arc<Node>,
        faction: Arc<Faction>,
        _battle_duration: u64,
    ) -> Option<f32> {
        //NOTE: Currently this does not take input stockpiles of any kind into account. We may wish to change this.
        //we add up all the resource quantity in factory output stockpiles in the node
        let factorysupply: u64 = if node.mutables.read().unwrap().allegiance == faction {
            node.mutables
                .read()
                .unwrap()
                .factories
                .iter()
                .map(|factory| factory.get_resource_supply_total(self.clone()))
                .sum::<u64>()
        } else {
            0
        };
        //then all the valid resource quantity in units
        let shipsupply: u64 = node
            .unit_container
            .read()
            .unwrap()
            .contents
            .iter()
            .filter(|unit| unit.get_allegiance() == faction)
            .map(|unit| unit.get_resource_supply(self.clone()))
            .sum::<u64>();
        //then sum them together
        let sum = (factorysupply + shipsupply) as f32;
        if sum == 0_f32 {
            None
        } else {
            Some(sum * self.value_mult)
        }
    }
}

//this method tells us how much demand there is for a given resource in a given node
impl Salience<polarity::Demand> for Arc<Resource> {
    fn calculate_node_salience(
        self,
        _root: &Root,
        node: Arc<Node>,
        faction: Arc<Faction>,
        _battle_duration: u64,
    ) -> Option<f32> {
        //add up resources from factory input stockpiles in node
        let factorydemand: u64 = if node.mutables.read().unwrap().allegiance == faction {
            node.mutables
                .read()
                .unwrap()
                .factories
                .iter()
                .map(|factory| factory.get_resource_demand_total(self.clone()))
                .sum::<u64>()
        } else {
            0
        };
        //add up resources from shipyard input stockpiles in node
        let shipyarddemand: u64 = if node.mutables.read().unwrap().allegiance == faction {
            node.mutables
                .read()
                .unwrap()
                .shipyards
                .iter()
                .map(|shipyard| shipyard.get_resource_demand_total(self.clone()))
                .sum::<u64>()
        } else {
            0
        };
        //now we have to look at units in the node, since they might have stockpiles of their own
        let shipdemand: u64 = node
            .unit_container
            .read()
            .unwrap()
            .contents
            .iter()
            .filter(|unit| unit.get_allegiance() == faction)
            .map(|unit| unit.get_resource_demand(self.clone()))
            .sum::<u64>();
        //and sum everything together
        let sum = (factorydemand + shipyarddemand + shipdemand) as f32;
        if sum == 0_f32 {
            None
        } else {
            Some(sum * self.value_mult)
        }
    }
}

//this method tells us how much supply there is of a given shipclass in a given node
impl Salience<polarity::Supply> for UnitClass {
    fn calculate_node_salience(
        self,
        _root: &Root,
        node: Arc<Node>,
        faction: Arc<Faction>,
        _battle_duration: u64,
    ) -> Option<f32> {
        let sum = node
            .unit_container
            .read()
            .unwrap()
            .contents
            .iter()
            .filter(|unit| unit.is_alive())
            .filter(|unit| unit.get_allegiance() == faction)
            .map(|unit| unit.get_unitclass_supply_recursive(self.clone()))
            .sum::<u64>() as f32;
        if sum == 0_f32 {
            None
        } else {
            Some(sum * self.get_value_mult())
        }
    }
}

//this method tells us how much demand there is for a given shipclass in a given node
impl Salience<polarity::Demand> for UnitClass {
    fn calculate_node_salience(
        self,
        _root: &Root,
        node: Arc<Node>,
        faction: Arc<Faction>,
        _battle_duration: u64,
    ) -> Option<f32> {
        let sum = node
            .unit_container
            .read()
            .unwrap()
            .contents
            .iter()
            .filter(|unit| unit.is_alive())
            .filter(|unit| unit.get_allegiance() == faction)
            .map(|unit| unit.get_unitclass_demand_recursive(self.clone()))
            .sum::<u64>() as f32;
        if sum == 0_f32 {
            None
        } else {
            Some(sum * self.get_value_mult())
        }
    }
}

pub fn transpose<T>(v: &Vec<Vec<T>>) -> Vec<Vec<T>>
where
    T: Clone,
{
    assert!(!v.is_empty());
    (0..v[0].len())
        .map(|i| v.iter().map(|inner| inner[i].clone()).collect::<Vec<T>>())
        .collect()
}

//TODO: make the logic apply more generally to stockpiles attached to ships

#[derive(Debug, Serialize, Deserialize)]
pub struct GlobalSalience {
    pub faction_salience: RwLock<Vec<Vec<Vec<[f32; 2]>>>>,
    pub resource_salience: RwLock<Vec<Vec<Vec<[f32; 2]>>>>,
    pub unitclass_salience: RwLock<Vec<Vec<Vec<[f32; 2]>>>>,
    pub strategic_weapon_effect_map: RwLock<Vec<Vec<[(i64, f32); 3]>>>,
}
