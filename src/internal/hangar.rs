pub use crate::internal::engagement::{
    Engagement, EngagementPrep, EngagementRecord, FactionForces, FactionForcesRecord, UnitRecord,
    UnitStatus,
};
pub use crate::internal::faction::{Faction, FactionID};
pub use crate::internal::node::{EdgeFlavor, Edges, Locality, Node, NodeFlavor, NodeMut, System};
pub use crate::internal::resource::{
    Engine, EngineClass, Factory, FactoryClass, PluripotentStockpile, Repairer, RepairerClass,
    Resource, ResourceProcess, SharedStockpile, Shipyard, ShipyardClass, Stockpileness,
    StrategicWeapon, StrategicWeaponClass, UnipotentStockpile,
};
use crate::internal::root::Root;
pub use crate::internal::salience::{
    polarity, scale_from_threat, transpose, GlobalSalience, Polarity, Salience,
};
pub use crate::internal::unit::{
    Mobility, Ship, ShipAI, ShipClass, ShipClassID, ShipFlavor, ShipHealth, ShipMut, Squadron,
    SquadronClass, SquadronClassID, SquadronFlavor, SquadronMut, Subsystem, SubsystemClass, Unit,
    UnitClass, UnitClassID, UnitLocation,
};
use serde::{Deserialize, Serialize};
use std::cmp::Ordering;
use std::collections::HashMap;
use std::hash::{Hash, Hasher};
use std::sync::atomic::{self, AtomicU64};
use std::sync::Arc;
use std::sync::{RwLock, RwLockWriteGuard};

#[derive(Debug, Clone)]
pub struct UnitContainer {
    pub contents: Vec<Unit>,
}

impl UnitContainer {
    pub fn new() -> UnitContainer {
        UnitContainer {
            contents: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HangarClass {
    pub id: usize,
    pub visible_name: String,
    pub description: String,
    pub visibility: bool,
    pub capacity: u64,                     //total volume the hangar can hold
    pub target: u64, //volume the hangar wants to hold; this is usually equal to capacity
    pub allowed: Option<Vec<UnitClassID>>, //which shipclasses this hangar can hold
    pub ideal: HashMap<UnitClassID, u64>, //how many of each ship type the hangar wants
    pub sub_target_supply_scalar: f32, //multiplier used for supply generated by non-ideal units under the target limit; should be below one
    pub non_ideal_demand_scalar: f32, //multiplier used for demand generated for non-ideal unitclasses; should be below one
    pub transport: bool, //whether hangar exists primarily to transport ships to a destination, rather than launch ships into combat or utility roles
    pub launch_volume: u64, //how much volume the hangar can launch at one time in battle
    pub launch_interval: u64, //time between launches in battle
    pub propagates: bool, //whether or not hangar generates saliences
}

impl PartialEq for HangarClass {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

impl Eq for HangarClass {}

impl Ord for HangarClass {
    fn cmp(&self, other: &Self) -> Ordering {
        self.id.cmp(&other.id)
    }
}

impl PartialOrd for HangarClass {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.id.partial_cmp(&other.id)
    }
}

impl Hash for HangarClass {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.id.hash(state);
    }
}

impl HangarClass {
    pub fn get_ideal_strength(&self, root: &Root) -> u64 {
        self.ideal
            .iter()
            .map(|(unitclass, v)| {
                let ideal_strength = match unitclass {
                    UnitClassID::ShipClass(sc) => {
                        root.shipclasses[sc.index].get_ideal_strength(root)
                    }
                    UnitClassID::SquadronClass(fc) => {
                        root.squadronclasses[fc.index].get_ideal_strength(root)
                    }
                };
                ideal_strength * v
            })
            .sum()
    }
    pub fn instantiate(
        class: Arc<Self>,
        mother: Arc<Ship>,
        _shipclasses: &Vec<Arc<ShipClass>>,
        counter: &Arc<AtomicU64>,
    ) -> Hangar {
        let index = counter.fetch_add(1, atomic::Ordering::Relaxed);
        Hangar {
            id: index,
            class: class.clone(),
            mother: mother.clone(),
            mutables: RwLock::new(HangarMut {
                visibility: class.visibility,
            }),
            unit_container: RwLock::new(UnitContainer::new()),
        }
    }
}

#[derive(Debug, Clone)]
pub struct HangarMut {
    pub visibility: bool,
}

#[derive(Debug)]
pub struct Hangar {
    pub id: u64,
    pub class: Arc<HangarClass>,
    pub mother: Arc<Ship>,
    pub mutables: RwLock<HangarMut>,
    pub unit_container: RwLock<UnitContainer>,
}

impl Hangar {
    pub fn get_strength(&self, time: u64) -> u64 {
        let contents = self
            .unit_container
            .read()
            .unwrap()
            .contents
            .iter()
            .filter(|unit| unit.is_alive())
            .map(|daughter| daughter.clone())
            .collect::<Vec<_>>();
        let contents_strength = contents
            .iter()
            .map(|unit| unit.get_strength(time))
            .sum::<u64>() as f32;
        let contents_vol = contents
            .iter()
            .map(|unit| unit.get_real_volume())
            .sum::<u64>() as f32;
        //we calculate how much of its complement the hangar can launch during a battle a certain number of seconds long
        let launch_mod = ((contents_vol / self.class.launch_volume as f32)
            * (time as f32 / self.class.launch_interval as f32))
            .clamp(0.0, 1.0);
        (contents_strength * launch_mod) as u64
    }
    pub fn get_strength_locked(
        &self,
        hangars_containers_lock: &HashMap<u64, RwLockWriteGuard<UnitContainer>>,
        squadrons_containers_lock: &HashMap<u64, RwLockWriteGuard<UnitContainer>>,
        ships_mut_lock: &HashMap<u64, RwLockWriteGuard<ShipMut>>,
        squadrons_mut_lock: &HashMap<u64, RwLockWriteGuard<SquadronMut>>,
        container_is_not_empty_map: &HashMap<u64, bool>,
        time: u64,
    ) -> u64 {
        let contents = hangars_containers_lock
            .get(&self.id)
            .unwrap()
            .contents
            .iter()
            .filter(|unit| {
                unit.is_alive_locked(
                    ships_mut_lock,
                    squadrons_mut_lock,
                    container_is_not_empty_map,
                )
            })
            .collect::<Vec<_>>();
        let contents_strength = contents
            .iter()
            .map(|unit| {
                unit.get_strength_locked(
                    hangars_containers_lock,
                    squadrons_containers_lock,
                    ships_mut_lock,
                    squadrons_mut_lock,
                    container_is_not_empty_map,
                    time,
                )
            })
            .sum::<u64>() as f32;
        let contents_vol = contents
            .iter()
            .map(|unit| unit.get_real_volume_locked(squadrons_containers_lock, ships_mut_lock))
            .sum::<u64>() as f32;
        //we calculate how much of its complement the hangar can launch during a battle a certain number of seconds long
        let launch_mod = ((contents_vol / self.class.launch_volume as f32)
            * (time as f32 / self.class.launch_interval as f32))
            .clamp(0.0, 1.0);
        (contents_strength * launch_mod) as u64
    }
    pub fn get_fullness(&self) -> u64 {
        self.unit_container
            .read()
            .unwrap()
            .contents
            .iter()
            .filter(|unit| unit.is_alive())
            .map(|unit| unit.get_real_volume())
            .sum()
    }
    pub fn get_unitclass_num_recursive(&self, unitclass: UnitClass) -> u64 {
        let unitclass_id = UnitClassID::new_from_unitclass(&unitclass);
        if self
            .class
            .allowed
            .as_ref()
            .map(|allowed_vec| allowed_vec.contains(&unitclass_id))
            .unwrap_or(true)
        {
            self.unit_container
                .read()
                .unwrap()
                .contents
                .iter()
                .filter(|unit| unit.is_alive())
                .map(|daughter| daughter.get_unitclass_num(unitclass.clone()))
                .sum::<u64>()
        } else {
            0
        }
    }
    pub fn get_unitclass_supply_recursive(&self, unitclass: UnitClass) -> u64 {
        let unitclass_id = UnitClassID::new_from_unitclass(&unitclass);
        if self
            .class
            .allowed
            .as_ref()
            .map(|allowed_vec| allowed_vec.contains(&unitclass_id))
            .unwrap_or(true)
        {
            let daughter_supply = self
                .unit_container
                .read()
                .unwrap()
                .contents
                .iter()
                .filter(|unit| unit.is_alive())
                .map(|daughter| daughter.get_unitclass_supply_recursive(unitclass.clone()))
                .sum::<u64>();
            let ideal_volume = self
                .class
                .ideal
                .get(&UnitClassID::new_from_unitclass(&unitclass))
                .unwrap_or(&0)
                * unitclass.get_ideal_volume();
            let non_ideal_volume = daughter_supply.saturating_sub(ideal_volume);
            let excess_volume = self.get_fullness().saturating_sub(self.class.target);
            let over_target_supply = (excess_volume).min(non_ideal_volume);
            let under_target_supply = ((non_ideal_volume.saturating_sub(over_target_supply)) as f32
                * self.class.sub_target_supply_scalar) as u64;
            over_target_supply + under_target_supply
        } else {
            0
        }
    }
    pub fn get_unitclass_supply_local(
        &self,
        unit_container: &RwLockWriteGuard<UnitContainer>,
        unitclass: UnitClass,
        ships_mut_lock: &HashMap<u64, RwLockWriteGuard<ShipMut>>,
        squadrons_containers_lock: &HashMap<u64, RwLockWriteGuard<UnitContainer>>,
    ) -> u64 {
        let unitclass_id = UnitClassID::new_from_unitclass(&unitclass);
        if self
            .class
            .allowed
            .as_ref()
            .map(|allowed_vec| allowed_vec.contains(&unitclass_id))
            .unwrap_or(true)
        {
            unit_container
                .contents
                .iter()
                .filter(|unit| {
                    unit.get_ship()
                        .map(|ship| ships_mut_lock.get(&ship.id).unwrap().hull.get() > 0)
                        .unwrap_or(true)
                })
                .filter(|daughter| &daughter.get_unitclass() == &unitclass)
                .map(|daughter| {
                    daughter.get_real_volume_locked(squadrons_containers_lock, ships_mut_lock)
                })
                .sum()
        } else {
            0
        }
    }
    pub fn get_unitclass_demand_recursive(&self, unitclass: UnitClass) -> u64 {
        let unitclass_id = UnitClassID::new_from_unitclass(&unitclass);
        if self
            .class
            .allowed
            .as_ref()
            .map(|allowed_vec| allowed_vec.contains(&unitclass_id))
            .unwrap_or(true)
        {
            let unit_container = self.unit_container.read().unwrap();
            let daughter_volume = unit_container
                .contents
                .iter()
                .filter(|unit| unit.is_alive())
                .filter(|unit| &unit.get_unitclass() == &unitclass)
                .map(|unit| unit.get_real_volume())
                .sum::<u64>();
            let ideal_volume = self
                .class
                .ideal
                .get(&UnitClassID::new_from_unitclass(&unitclass))
                .unwrap_or(&0)
                * unitclass.get_ideal_volume();
            let ideal_demand = ideal_volume.saturating_sub(daughter_volume);
            let non_ideal_demand = (self
                .class
                .target
                .saturating_sub(self.get_fullness())
                .saturating_sub(ideal_demand) as f32
                * self.class.non_ideal_demand_scalar) as u64;
            ideal_demand
                + non_ideal_demand
                + unit_container
                    .contents
                    .iter()
                    .filter(|unit| unit.is_alive())
                    .map(|daughter| daughter.get_unitclass_demand_recursive(unitclass.clone()))
                    .sum::<u64>()
        } else {
            0
        }
    }
    pub fn get_unitclass_demand_local(
        &self,
        unit_container: &RwLockWriteGuard<UnitContainer>,
        unitclass: UnitClass,
        ships_mut_lock: &HashMap<u64, RwLockWriteGuard<ShipMut>>,
        squadrons_containers_lock: &HashMap<u64, RwLockWriteGuard<UnitContainer>>,
    ) -> u64 {
        let unitclass_id = UnitClassID::new_from_unitclass(&unitclass);
        if self
            .class
            .allowed
            .as_ref()
            .map(|allowed_vec| allowed_vec.contains(&unitclass_id))
            .unwrap_or(true)
        {
            let daughter_volume = unit_container
                .contents
                .iter()
                .filter(|unit| {
                    unit.get_ship()
                        .map(|ship| ships_mut_lock.get(&ship.id).unwrap().hull.get() > 0)
                        .unwrap_or(true)
                })
                .filter(|unit| &unit.get_unitclass() == &unitclass)
                .map(|unit| unit.get_real_volume_locked(squadrons_containers_lock, ships_mut_lock))
                .sum::<u64>();
            let ideal_volume = self
                .class
                .ideal
                .get(&UnitClassID::new_from_unitclass(&unitclass))
                .unwrap_or(&0)
                * unitclass.get_ideal_volume();
            let ideal_demand = ideal_volume.saturating_sub(daughter_volume);
            let non_ideal_demand = (self
                .class
                .target
                .saturating_sub(
                    unit_container
                        .contents
                        .iter()
                        .filter(|unit| {
                            unit.get_ship()
                                .map(|ship| ships_mut_lock.get(&ship.id).unwrap().hull.get() > 0)
                                .unwrap_or(true)
                        })
                        .map(|unit| {
                            unit.get_real_volume_locked(squadrons_containers_lock, ships_mut_lock)
                        })
                        .sum::<u64>(),
                )
                .saturating_sub(ideal_demand) as f32
                * self.class.non_ideal_demand_scalar) as u64;
            ideal_demand + non_ideal_demand
        } else {
            0
        }
    }
    pub fn get_transport_transaction_unitclass_demand(
        &self,
        unit_container: &RwLockWriteGuard<UnitContainer>,
        unitclass: UnitClass,
        ships_mut_lock: &HashMap<u64, RwLockWriteGuard<ShipMut>>,
        external_demand: f32,
        speed_factor: f32,
        total_naive_demand: f32,
    ) -> u64 {
        let unitclass_id = UnitClassID::new_from_unitclass(&unitclass);
        if self
            .class
            .allowed
            .as_ref()
            .map(|allowed_vec| allowed_vec.contains(&unitclass_id))
            .unwrap_or(true)
        {
            let ideal_volume =
                self.class.ideal.get(&unitclass_id).unwrap_or(&0) * unitclass.get_ideal_volume();
            let space_left_without_unitclass = self.class.target.saturating_sub(
                unit_container
                    .contents
                    .iter()
                    .filter(|unit| {
                        unit.get_ship()
                            .map(|ship| ships_mut_lock.get(&ship.id).unwrap().hull.get() > 0)
                            .unwrap_or(true)
                    })
                    .filter(|unit| unit.get_unitclass().get_id() != unitclass.get_id())
                    .map(|unit| unit.get_real_volume())
                    .sum(),
            );
            let non_ideal_volume = space_left_without_unitclass.saturating_sub(ideal_volume);
            let self_demand = ideal_volume
                + (non_ideal_volume as f32 * self.class.non_ideal_demand_scalar) as u64;
            ((external_demand * speed_factor * (self_demand as f32 / total_naive_demand)) as u64)
                .clamp(0, self_demand)
        } else {
            0
        }
    }
}

impl PartialEq for Hangar {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

impl Eq for Hangar {}

impl Ord for Hangar {
    fn cmp(&self, other: &Self) -> Ordering {
        self.id.cmp(&other.id)
    }
}

impl PartialOrd for Hangar {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.id.partial_cmp(&other.id)
    }
}

impl Hash for Hangar {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.id.hash(state);
    }
}
