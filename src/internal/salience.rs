use crate::internal::faction::{Faction, FactionID};
use crate::internal::node::{Locality, Node};
use crate::internal::resource::{Resource, ResourceProcess};
use crate::internal::root::Root;
use crate::internal::unit::{Mobility, ShipClass, SquadronClass, UnitClass};
use rayon::prelude::*;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use std::sync::RwLock;

//this takes an unbounded threat value and converts it to a multiplier between zero and one by which to scale saliences as they pass through the node
pub fn scale_from_threat(threat: f32, scaling_factor: f32) -> f32 {
    if scaling_factor <= 0. {
        panic!(
            "Attempted to scale by nonpositive factor {}",
            scaling_factor
        );
    }

    let base = 0.95;
    let minimum_valid_threat_value = threat.abs() + scaling_factor;
    let downscaled_threat = minimum_valid_threat_value / scaling_factor;

    let delta_base = 1. - (1. / downscaled_threat);
    let maximum_delta = if threat >= 0. { 0.05 } else { -0.95 };
    let delta = maximum_delta * delta_base;

    base + delta
}

//polarity denotes whether a salience value represents supply or demand
//threat doesn't have demand
//at least not yet
//we might want to change that eventually
pub trait Polarity {}

//we put polarities in a dummy module for syntactic prettiness reasons
pub mod polarity {

    use super::Polarity;

    #[derive(Copy, Clone)]
    pub struct Supply {}

    impl Polarity for Supply {}

    #[derive(Copy, Clone)]
    pub struct Demand {}

    impl Polarity for Demand {}
}

pub trait Salience<P: Polarity> {
    //this retrieves the value of a specific salience in a specific node
    fn calculate_node_salience(
        self,
        root: &Root,
        node: Arc<Node>,
        faction: Arc<Faction>,
        battle_duration: u64,
    ) -> Option<f32>;
}

//this method retrieves threat value generated by a given faction
impl Salience<polarity::Supply> for Arc<Faction> {
    fn calculate_node_salience(
        self,
        _root: &Root,
        node: Arc<Node>,
        faction: Arc<Faction>,
        battle_duration: u64,
    ) -> Option<f32> {
        let node_strength: u64 = node.get_strength(self.clone(), battle_duration);
        //here we get the relations value -- the subject faction's opinion of the object faction, which will influence the threat value
        let relation = faction
            .relations
            .get(&FactionID::new_from_index(self.id))
            .unwrap();
        Some(node_strength)
            .filter(|&strength| strength != 0)
            .map(|strength| strength as f32 * relation * self.value_mult)
    }
}

impl Salience<polarity::Demand> for Arc<Faction> {
    fn calculate_node_salience(
        self,
        root: &Root,
        node: Arc<Node>,
        faction: Arc<Faction>,
        _battle_duration: u64,
    ) -> Option<f32> {
        //Here, we don't take the object faction's relations with the subject faction into account at all,
        //because subjectivity isn't really relevant for threat demand.
        //NOTE: Doing this by retrieving the data from salience state (rather than by looking at assets in the node directly) means that a node will want friendly forces corresponding to assets in other nodes
        //which are propagating salience into it. Not sure if this is desirable behavior.
        if faction == self {
            let resource_salience_by_node: Vec<Vec<[f32; 2]>> =
                transpose(&root.global_salience.resource_salience.read().unwrap()[self.id]);
            let resource_supply: f32 = resource_salience_by_node[node.id]
                .iter()
                .map(|array| array[0])
                .sum();
            let unitclass_salience_by_node: Vec<Vec<[f32; 2]>> =
                transpose(&root.global_salience.unitclass_salience.read().unwrap()[self.id]);
            let unitclass_supply: f32 = unitclass_salience_by_node[node.id]
                .iter()
                .map(|array| array[0])
                .sum();
            let node_value = resource_supply + unitclass_supply;
            let node_object_faction_supply =
                root.global_salience.faction_salience.read().unwrap()[self.id][self.id][node.id][0];
            Some(
                ((node_value
                    * self.volume_strength_ratio
                    * root.config.salience_scalars.volume_strength_ratio)
                    - node_object_faction_supply.clamp(0.0, f32::MAX))
                    * self.value_mult,
            )
        } else {
            None
        }
    }
}

//this method tells us how much supply there is of a given resource in a given node
impl Salience<polarity::Supply> for Arc<Resource> {
    fn calculate_node_salience(
        self,
        _root: &Root,
        node: Arc<Node>,
        faction: Arc<Faction>,
        _battle_duration: u64,
    ) -> Option<f32> {
        let sum = node.get_resource_supply(faction, self.clone()) as f32;
        if sum == 0_f32 {
            None
        } else {
            Some(sum * self.value_mult)
        }
    }
}

//this method tells us how much demand there is for a given resource in a given node
impl Salience<polarity::Demand> for Arc<Resource> {
    fn calculate_node_salience(
        self,
        _root: &Root,
        node: Arc<Node>,
        faction: Arc<Faction>,
        _battle_duration: u64,
    ) -> Option<f32> {
        //add up resources from factory input stockpiles in node
        let factorydemand: u64 = if node.mutables.read().unwrap().allegiance == faction {
            node.mutables
                .read()
                .unwrap()
                .factories
                .iter()
                .map(|factory| factory.get_resource_demand_total(self.clone()))
                .sum::<u64>()
        } else {
            0
        };
        //add up resources from shipyard input stockpiles in node
        let shipyarddemand: u64 = if node.mutables.read().unwrap().allegiance == faction {
            node.mutables
                .read()
                .unwrap()
                .shipyards
                .iter()
                .map(|shipyard| shipyard.get_resource_demand_total(self.clone()))
                .sum::<u64>()
        } else {
            0
        };
        //now we have to look at units in the node, since they might have stockpiles of their own
        let shipdemand: u64 = node
            .unit_container
            .read()
            .unwrap()
            .contents
            .iter()
            .filter(|unit| unit.get_allegiance() == faction)
            .map(|unit| unit.get_resource_demand(self.clone()))
            .sum::<u64>();
        //and sum everything together
        let sum = (factorydemand + shipyarddemand + shipdemand) as f32;
        if sum == 0_f32 {
            None
        } else {
            Some(sum * self.value_mult)
        }
    }
}

//this method tells us how much supply there is of a given shipclass in a given node
impl Salience<polarity::Supply> for UnitClass {
    fn calculate_node_salience(
        self,
        _root: &Root,
        node: Arc<Node>,
        faction: Arc<Faction>,
        _battle_duration: u64,
    ) -> Option<f32> {
        let sum = node
            .unit_container
            .read()
            .unwrap()
            .contents
            .iter()
            .filter(|unit| unit.is_alive())
            .filter(|unit| unit.get_allegiance() == faction)
            .map(|unit| unit.get_unitclass_supply_recursive(self.clone()))
            .sum::<u64>() as f32;
        if sum == 0_f32 {
            None
        } else {
            Some(sum * self.get_value_mult())
        }
    }
}

//this method tells us how much demand there is for a given shipclass in a given node
impl Salience<polarity::Demand> for UnitClass {
    fn calculate_node_salience(
        self,
        _root: &Root,
        node: Arc<Node>,
        faction: Arc<Faction>,
        _battle_duration: u64,
    ) -> Option<f32> {
        let sum = node
            .unit_container
            .read()
            .unwrap()
            .contents
            .iter()
            .filter(|unit| unit.is_alive())
            .filter(|unit| unit.get_allegiance() == faction)
            .map(|unit| unit.get_unitclass_demand_recursive(self.clone()))
            .sum::<u64>() as f32;
        if sum == 0_f32 {
            None
        } else {
            Some(sum * self.get_value_mult())
        }
    }
}

pub fn transpose<T>(v: &Vec<Vec<T>>) -> Vec<Vec<T>>
where
    T: Clone,
{
    assert!(!v.is_empty());
    (0..v[0].len())
        .map(|i| v.iter().map(|inner| inner[i].clone()).collect::<Vec<T>>())
        .collect()
}

//TODO: make the logic apply more generally to stockpiles attached to ships

#[derive(Debug, Serialize, Deserialize)]
pub struct GlobalSalience {
    pub faction_salience: RwLock<Vec<Vec<Vec<[f32; 2]>>>>,
    pub resource_salience: RwLock<Vec<Vec<Vec<[f32; 2]>>>>,
    pub unitclass_salience: RwLock<Vec<Vec<Vec<[f32; 2]>>>>,
    pub strategic_weapon_effect_map: RwLock<Vec<Vec<[(i64, f32); 3]>>>,
}

impl Root {
    //oh god
    pub fn calculate_salience<S: Salience<P> + Clone, P: Polarity>(
        //we need a salience, which is the type of resource or shipclass or whatever we're calculating values for
        //and the faction for which we're calculating values
        //and we specify the number of times we want to calculate these values, (NOTE: uncertain) i.e. the number of edges we'll propagate across
        &self,
        salience: S,
        subject_faction: Arc<Faction>,
        deg_mult: f32,
        n_iters: usize,
    ) -> Vec<f32> {
        //this map only contains the salience values being generated by things directly in each node, without any propagation
        //we call get_value on the salience, and return the node id and salience value, while filtering down to only the nodes producing the subject salience
        //Length equals nodes producing subject salience
        let node_initial_salience_map: Vec<(Arc<Node>, f32)> = self
            .nodes
            .iter()
            .filter_map(|node| {
                salience
                    .clone()
                    .calculate_node_salience(
                        &self,
                        node.clone(),
                        subject_faction.clone(),
                        self.config.battle_scalars.avg_duration,
                    )
                    .map(|v| (node.clone(), v))
            })
            .collect();
        //this map contains the amount of threat that exists from each faction, in each node, from the perspective of the subject faction
        //Length equals all nodes
        //This is a subjective map for subject faction
        let tagged_threats: Vec<Vec<[f32; 2]>> =
            transpose(&self.global_salience.faction_salience.read().unwrap()[subject_faction.id]);
        //this is the factor by which a salience passing through each node should be multiplied
        //we sum the tagged threats for each node -- which are valenced according to relations with the subject faction
        //then we use the scaling math to convert them so that the scaling curve is correct
        //Length equals all nodes
        //This is a subjective map for subject faction
        let node_degradations: Vec<f32> = tagged_threats
            .iter()
            .map(|factions_vec| {
                let sum = factions_vec.iter().map(|[supply, _]| supply).sum();
                scale_from_threat(sum, 20_f32) * deg_mult * 0.8
            })
            .collect();
        //Outer vec length equals all nodes; inner vec equals nodes owned by faction and producing specified salience -- but only the inner node corresponding to the outer node has a nonzero value
        let node_salience_state: Vec<Vec<f32>> = self
            .nodes
            .iter()
            .map(|node| {
                //we iterate over the node initial salience map, which contains only nodes owned by subject faction and producing subject salience
                node_initial_salience_map
                    .iter()
                    //that gives us the initial salience value for each node
                    //we use this '== check as u8' to multiply it by 1 if the node matches the one the outer iterator is looking at, and multiply it by 0 otherwise
                    .map(|(sourcenode, value)| {
                        value * ((sourcenode.clone() == node.clone()) as u8) as f32
                    })
                    .collect()
            })
            .collect();
        //this gives us a list of all nodes, with each node having an inner list of subject-subject nodes
        //if the node is a subject-subject node, then its inner list contains a self-entry indicating the salience it's generating, but all other values are zero
        //this will let us tag propagated saliences by their source so they don't improperly compound each other
        let n_tags = node_initial_salience_map.len();
        let node_salience_state =
            //there are three layers of iteration here
            //first we fold over node_salience_state as many times as specified by n_iters, defined earlier
            //then we iterate over all the edges
            //and inside that iteration we loop the salience propagation process as many times as there are relevant nodes (producing the salience and owned subject faction)
            //this way we can process each salience source separately, avoiding compounding
            (0..n_iters).fold(node_salience_state, |mut state, _| {
                //println!("Completed {} iterations of salience propagation.", n_iter);
                self.edges.iter().filter(|(_, flavor)| flavor.propagates).for_each(|((a, b), _)| {
                    //we get the degradation scalar for each of the two nodes in the edge
                    let deg_a = node_degradations[a.id];
                    let deg_b = node_degradations[b.id];
                    //this loop does basically the same thing as an iterator but we have to do it this way for complicated ownership reasons
                    //we repeat the loop process n_tags times, 
                    for i in 0..n_tags {
                        //we index into node_salience_state's outer vec by node A's id, then into the inner vec by i; this means we're essentially iterating over the inner vec
                        //we update the i'th element of A (the inner vec) by taking the maximum between the i'th element of A and the i'th element of B, multiplied by node B's degradation scalar
                        //because this is the salience coming from node B to node A, getting degraded by B's threats as it leaves
                        state[a.id][i] = state[a.id][i].max(state[b.id][i] * deg_b);
                        //then we do the same thing again but backwards, to process the salience coming from node A to node B
                        state[b.id][i] = state[b.id][i].max(state[a.id][i] * deg_a);
                    }
                });
                //now we return the new state, with it having been updated
                state
            });
        //now we collapse all the different producers together so we can just look at how much salience each node contains from the perspective of the subject faction
        node_salience_state
            .iter()
            .map(|salience| salience.iter().sum())
            .collect()
    }
    pub fn calculate_global_faction_salience(&self) -> Vec<Vec<Vec<[f32; 2]>>> {
        self.factions
            .par_iter()
            .map(|subjectfaction| {
                self.factions
                    .par_iter()
                    .map(|objectfaction| {
                        if objectfaction.propagates {
                            let supply = self.calculate_salience::<Arc<Faction>, polarity::Supply>(
                                objectfaction.clone(),
                                subjectfaction.clone(),
                                self.config.salience_scalars.faction_deg_mult,
                                self.config.salience_scalars.faction_prop_iters,
                            );
                            let demand = self.calculate_salience::<Arc<Faction>, polarity::Demand>(
                                objectfaction.clone(),
                                subjectfaction.clone(),
                                self.config.salience_scalars.faction_deg_mult,
                                self.config.salience_scalars.faction_prop_iters,
                            );
                            supply
                                .iter()
                                .zip(demand.iter())
                                .map(|(s, d)| [*s, *d])
                                .collect()
                        } else {
                            self.nodes.iter().map(|_| [0.0; 2]).collect()
                        }
                    })
                    .collect()
            })
            .collect()
    }
    pub fn calculate_global_resource_salience(&self) -> Vec<Vec<Vec<[f32; 2]>>> {
        self.factions
            .par_iter()
            .map(|faction| {
                self.resources
                    .par_iter()
                    .map(|resource| {
                        if resource.propagates {
                            let supply = self
                                .calculate_salience::<Arc<Resource>, polarity::Supply>(
                                    resource.clone(),
                                    faction.clone(),
                                    self.config.salience_scalars.resource_deg_mult,
                                    self.config.salience_scalars.resource_prop_iters,
                                );
                            let demand = self
                                .calculate_salience::<Arc<Resource>, polarity::Demand>(
                                    resource.clone(),
                                    faction.clone(),
                                    self.config.salience_scalars.resource_deg_mult,
                                    self.config.salience_scalars.resource_prop_iters,
                                );
                            supply
                                .iter()
                                .zip(demand.iter())
                                .map(|(s, d)| [*s, *d])
                                .collect()
                        } else {
                            self.nodes.iter().map(|_| [0.0; 2]).collect()
                        }
                    })
                    .collect()
            })
            .collect()
    }
    pub fn calculate_global_unitclass_salience(&self) -> Vec<Vec<Vec<[f32; 2]>>> {
        self.factions
            .par_iter()
            .map(|faction| {
                self.shipclasses
                    .par_iter()
                    .map(|shipclass| {
                        if shipclass.propagates {
                            let supply = self.calculate_salience::<UnitClass, polarity::Supply>(
                                ShipClass::get_unitclass(shipclass.clone()),
                                faction.clone(),
                                self.config.salience_scalars.unitclass_deg_mult,
                                self.config.salience_scalars.unitclass_prop_iters,
                            );
                            let demand = self.calculate_salience::<UnitClass, polarity::Demand>(
                                ShipClass::get_unitclass(shipclass.clone()),
                                faction.clone(),
                                self.config.salience_scalars.unitclass_deg_mult,
                                self.config.salience_scalars.unitclass_prop_iters,
                            );
                            supply
                                .iter()
                                .zip(demand.iter())
                                .map(|(s, d)| [*s, *d])
                                .collect()
                        } else {
                            self.nodes.iter().map(|_| [0.0; 2]).collect()
                        }
                    })
                    .chain(self.squadronclasses.par_iter().map(|squadronclass| {
                        if squadronclass.propagates {
                            let supply = self.calculate_salience::<UnitClass, polarity::Supply>(
                                SquadronClass::get_unitclass(squadronclass.clone()),
                                faction.clone(),
                                self.config.salience_scalars.unitclass_deg_mult,
                                self.config.salience_scalars.unitclass_prop_iters,
                            );
                            let demand = self.calculate_salience::<UnitClass, polarity::Demand>(
                                SquadronClass::get_unitclass(squadronclass.clone()),
                                faction.clone(),
                                self.config.salience_scalars.unitclass_deg_mult,
                                self.config.salience_scalars.unitclass_prop_iters,
                            );
                            supply
                                .iter()
                                .zip(demand.iter())
                                .map(|(s, d)| [*s, *d])
                                .collect()
                        } else {
                            self.nodes.iter().map(|_| [0.0; 2]).collect()
                        }
                    }))
                    .collect()
            })
            .collect()
    }
    pub fn calculate_strategic_weapon_effect_map(&self) -> Vec<Vec<[(i64, f32); 3]>> {
        self.factions
            .iter()
            .map(|subject_faction| {
                self.ships
                    .read()
                    .unwrap()
                    .iter()
                    .filter(|ship| ship.mutables.read().unwrap().strategic_weapons.len() > 0)
                    .fold(
                        self.nodes.iter().map(|_| [(0, 0.0); 3]).collect(),
                        |mut acc: Vec<[(i64, f32); 3]>, ship| {
                            ship.mutables
                                .read()
                                .unwrap()
                                .strategic_weapons
                                .iter()
                                .filter(|weapon| {
                                    weapon.targets_faction(
                                        &self,
                                        &ship.get_allegiance(),
                                        subject_faction,
                                    )
                                })
                                .for_each(|weapon| {
                                    let damage = (
                                        (weapon.class.damage.0 .0 + weapon.class.damage.0 .1) / 2,
                                        (weapon.class.damage.1 .0 + weapon.class.damage.1 .1) / 2.0,
                                    );
                                    let engine_damage = (
                                        (weapon.class.engine_damage.0 .0
                                            + weapon.class.engine_damage.0 .1)
                                            / 2,
                                        (weapon.class.engine_damage.1 .0
                                            + weapon.class.engine_damage.1 .1)
                                            / 2.0,
                                    );
                                    let strategic_weapon_damage = (
                                        (weapon.class.strategic_weapon_damage.0 .0
                                            + weapon.class.strategic_weapon_damage.0 .1)
                                            / 2,
                                        (weapon.class.strategic_weapon_damage.1 .0
                                            + weapon.class.strategic_weapon_damage.1 .1)
                                            / 2.0,
                                    );
                                    let target_nodes = ship.get_mother_node().get_nodes_in_range(
                                        self,
                                        weapon.class.range,
                                        &weapon.class.forbidden_nodeflavors,
                                        &weapon.class.forbidden_edgeflavors,
                                    );
                                    target_nodes.iter().for_each(|node| {
                                        acc[node.id][0].0 += damage.0;
                                        acc[node.id][0].1 += damage.1;
                                        acc[node.id][1].0 += engine_damage.0;
                                        acc[node.id][1].1 += engine_damage.1;
                                        acc[node.id][2].0 += strategic_weapon_damage.0;
                                        acc[node.id][2].1 += strategic_weapon_damage.1;
                                    })
                                });
                            acc
                        },
                    )
            })
            .collect()
    }
}
